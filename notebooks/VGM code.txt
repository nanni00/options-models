VARIANCE GAMMA MODEL: 

def vg_charfunc(phi, S0, theta, sigma, nu, tau, r):
    """
    Variance Gamma characteristic function of ln(S_tau).
    
    ----------
    Parameters
    phi   : float or ndarray
        Frequency argument of the characteristic function.
    S0    : float
        Spot price at t=0.
    theta : float
        'Drift' parameter of the VG subordinator (sometimes denoted as θ).
    sigma : float
        'Vol' parameter of the VG subordinator.
    nu    : float
        'Gamma' parameter (sometimes 1/kappa in other notations).
    tau   : float
        Time to maturity (T - 0).
    r     : float
        Risk-free interest rate.
    -------
    Notes
    The key difference from Heston is the explicit "martingale adjustment" ω:
        ω = - (1/nu) * ln(1 - theta*nu - 0.5*sigma^2 * nu)
    so that discounted S_t is a martingale under the risk-neutral measure.
    -----
    j = 1j
    
    # Martingale adjustment: ensure E[e^{-r tau} * S_tau] = S_0
    omega = -(1.0 / nu) * np.log(1.0 - theta*nu - 0.5*sigma**2 * nu)
    
    # VG characteristic function for ln(S_tau):
    #   exp{ i φ [ ln(S0) + (r + ω)*τ ] } * (1 - i θ ν φ + 0.5 σ^2 ν φ^2)^(-τ/ν)
    return np.exp(
        j * phi * (np.log(S0) + (r + omega) * tau)
    ) * (
        1.0 - j*theta*nu*phi + 0.5*sigma**2 * nu * (phi**2)
    ) ** (-tau / nu)


def integrand_vg(phi, S0, K, theta, sigma, nu, tau, r):
   
    ----------
    Parameters
    phi   : float
        Integration variable (Fourier frequency).
    S0, K : float
        Spot (S0) and strike (K).
    theta, sigma, nu, tau, r : float
        VG parameters and maturity/rate.
    -------
    
    numerator = (
        np.exp(j * phi * r * tau) * vg_charfunc(phi - j, S0, theta, sigma, nu, tau, r)
        - K * vg_charfunc(phi, S0, theta, sigma, nu, tau, r)
    )
    denominator = j*phi * (j*phi + 1.0)
    
    return numerator / denominator


def vg_price_rec(S0, K, theta, sigma, nu, tau, r):

   ----------
   Parameters
    S0, K : float
        Spot and strike.
    theta, sigma, nu : float
        VG parameters.
    tau   : float
        Time to maturity.
    r     : float
        Risk-free interest rate.
    -------
   
    phi_max = 100.0
    N = 10000
    dphi = phi_max / N
    
    P = 0.0
    for i in range(1, N):
        # midpoint in each subinterval (rectangular rule)
        phi = dphi * (2*i - 1) / 2.0
        P += dphi * integrand_vg(phi, S0, K, theta, sigma, nu, tau, r)
    
    return np.real( (S0 - K * np.exp(-r*tau))/2.0 + P / np.pi )



